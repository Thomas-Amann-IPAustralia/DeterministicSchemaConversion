# schema_mapping.yaml
settings:
  source_folder: "./json_data"
  output_folder: "./output_tables"

# ---------------------------------------------------------
# Table Definitions
# ---------------------------------------------------------
tables:
  
  # 1. Primary Table (Metadata & Service Info)
  primary:
    filename: "Primary.csv"
    root_path: "$" # Root of the JSON
    columns:
      UDID: "identifier.value"
      Headline: "headline"
      Headline_Alt: "alternativeHeadline"
      Description: "description"
      Stable_URL: "url"
      Date_Published: "datePublished"
      Date_Modified: "dateModified"
      Geographic_Area: "audience.geographicArea.name"
      IP_Right_Name: "about.name"
      IP_Right_Wikidata_URL: "about.sameAs"
      Service_Type: "mainEntity[0].@type" # Assumes first entity defines type
      Service_Name: "mainEntity[0].name"
      HowTo_Name: "mainEntity[?(@.@type=='HowTo')].name" # JSONPath filter for HowTo
      Service_Provider: 
        path: "mainEntity[0].serviceOperator.name"
        default: "Self-service"
        logic: "if_article_then_self_service" # Custom logic hook

  # 2. Influences (Currently Placeholders)
  influences:
    filename: "Influences.csv"
    root_path: "$"
    columns:
      UDID: "identifier.value"
      Headline_Alt: "alternativeHeadline"
      Influence_Priority: "const:Null (FOR NOW)"
      Influence_ID: "const:Null (FOR NOW)"
      Influence_URL: "const:Null (FOR NOW)"

  # 3. LinksTo (Related Links)
  links_to:
    filename: "LinksTo.csv"
    root_path: "relatedLink[*]" # Iterates over the relatedLink array
    columns:
      UDID: "parent:identifier.value" # 'parent:' grabs from the root JSON, not the current item
      Headline_Alt: "parent:alternativeHeadline"
      Destination_URL: "url"
      Destination_name: "name"
      Internal_Destination: 
        path: "url"
        logic: "check_internal_link"
      Internal_Destination_UDID: 
        path: "url"
        logic: "extract_udid_from_url" # Placeholder logic

  # 4. HowTo (Steps)
  howto:
    filename: "HowTo.csv"
    # Complex path: Find the mainEntity that is a HowTo, then get its steps
    root_path: "mainEntity[?(@.@type=='HowTo')].step[*]" 
    columns:
      UDID: "parent:identifier.value"
      HowTo_Name: "parent:mainEntity[?(@.@type=='HowTo')].name"
      Step_Name: "name"
      Step_Description: "text"

  # 5. FAQ (Q&A)
  faq:
    filename: "FAQ.csv"
    # Complex path: Find the FAQPage, then iterate its mainEntity (Questions)
    root_path: "mainEntity[?(@.@type=='FAQPage')].mainEntity[*]"
    columns:
      UDID: "parent:identifier.value"
      Headline_Alt: "parent:alternativeHeadline"
      Question: "name"
      Answer: "acceptedAnswer.text"
      # Note: Your Excel flattens specific questions into columns (Benefits, Risks, Costs).
      # The generic script extracts them as rows. A 'pivot' logic would be required 
      # to match the exact wide-format of your Excel if strictly required, 
      # but row-based is better for SQL ingestion.
      # *Logic below attempts to categorize them for the 'pivot' style if needed*
      Category: 
        path: "name"
        logic: "categorize_faq"

  # 6. Semantic (Chunks - Placeholders)
  semantic:
    filename: "Semantic.csv"
    root_path: "$"
    columns:
      UDID: "identifier.value"
      Headline_Alt: "alternativeHeadline"
      Chunk_ID: "const:Null (FOR NOW)"
      Chunk_Token_Count: "const:Null (FOR NOW)"
      Chunk_Text: 
        path: "description" # Using description as a simple chunk for now
        logic: "append_headline"
      Chunk_Embedding: "const:Null (FOR NOW)"
      Chunk_Injection: "const:Null (FOR NOW)"

  # 7. Raw Data
  raw_data:
    filename: "RawData.csv"
    root_path: "$"
    columns:
      UDID: "identifier.value"
      Headline_Alt: "alternativeHeadline"
      
      # RAW HTML
      HTML_Raw: 
        logic: "get_raw_html"  # Looks for file in IPFR-Webpages-html matching JSON filename
      HTML_Raw_Token_Count: 
        logic: "count_raw_html"
      
      # RAW MARKDOWN
      MD_Raw: 
        logic: "get_raw_md"    # Looks for file in IPFR-Webpages matching JSON filename
      MD_Raw_Token_Count: 
        logic: "count_raw_md"
      
      # JSON
      JSON_Raw: "whole_json"
      Json_Raw_Token_Count: 
        logic: "count_json_tokens"
